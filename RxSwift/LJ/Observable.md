# Observable
---

## 🟡 **개요**
- 옵저버는 Observable을 구독한다.
- 마블다이어그램
    Observable과 Observable의 전환을 표현
    - 시간 축 :  과거 → 미래 방향
    - 이벤트의 발생 순서와 처리 순서가 일치한다.
<img width="700" alt="스크린샷 2023-08-16 오후 2 24 11" src="https://github.com/lj-7-77/practice/assets/97071996/f63bd417-017d-429e-b27d-b7b7cb89be02">

> 옵저버에 의해 임의의 순서에 따라 병렬로 실행되고 결과는 나중에 연산된다.
>
- 실행 == 연산..?
    실행은 여러 옵저버들이 각자 병렬로 실행 
    → 각각의 작업 결과도 병렬로 나옴 
    → 각 결과를 변환, 조작, 필터링, 결합하는건 나중에 연산된다는 의미
- 옵저버블 1개 - 여러 개의 옵저버가 동시에 구독하여 각각 동작, 이벤트를 비동기적으로 전달, 각각의 옵저버가 데이터를 처리하는 작업은 **병렬**로 실행
- 병렬로 실행된 작업들의 완료순서는 예측불가, 각각의 **작업 결과**가 나중에 연산된다.
- 옵저버블이 배출하는 데이터가 발생하는 시점 ≠ 각각의 옵저버가 데이터를 처리하는 시점  개별로 동작

> Observable은 *항목들*을 ***배출***하거나 observable의 **메서드 호출**을 통해 옵저버에게 ***알림***을 보낸다.

|  | |
| -------- | -------- |
| *메서드 호출* 보다는, <br> "Observable" 안에 데이터를 조회하고 변환하는 메커니즘을 정의한 후,<br> Observable이 이벤트를 **발생**시키면<br> 옵저버가 그 순간을 **포착**하고 <br>준비된 연산을 실행시켜 결과를 리턴하는 메커니즘 때문에,<br> observable을 구독한다.<br><br>1. 옵저버블에 옵저버 등록 <br> 2. 옵저버가 감시<br> 3. 옵저버블은 기다릴 필요 없이 진행<br> 4. 이벤트 배출 시 알림<br> 5. 옵저버가 알림 포착, 준비된 연산 실행  |<img width="300" alt="스크린샷 2023-08-16 오후 2 24 11" src="https://github.com/lj-7-77/practice/assets/97071996/ae4bd87b-dbbb-4fd9-b8fa-10072330156c">| 

> 옵저버 == 관찰자 == 구독자 == 리액터 로 불려지지만,  
통상적으로 리액터패턴 == 옵저버패턴 이다.
    
- 특징
    - 사용자 입력, 외부 이벤트에 반응하여 시스템의 상태를 변화시키는 패턴 (ex. UI, 네트워크 상호작용 등에 반응)
    - 앱의 상태 변화와 관련된 로직을 분리 → 유지보수성, 테스트 용이성 증가
        - 사용자 인터페이스에서 발생하는 이벤트 처리, 비동기적인 작업 처리, 상태 관리 등에 적용
        - 앱 상태 변화와 관련된 로직 (ex. 로그인을 하면 인증상태가 변경되는 로직)을 분리
---

## 🟡 **옵저버 생성**
- 일반적인 메서드 호출
    1. 메서드를 호출
    2. 메서드가 리턴한 값을 변수에 저장
    3. 결과 값을 가진 변수를 통해 필요한 연산을 처리
- 비동기 모델에서의 흐름
    1. 비동기 메소드 호출로 결과를 리턴받고 필요한 동작을 처리하는 메서드를 정의
        
        이 메서드는 *옵저버*의 일부가 된다.
        
    2. *Observable*로 비동기 호출을 정의
    3. *구독*을 통해 옵저버를 Observable 객체에 연결, 동시에 Observable의 동작을 초기화
    4. 메서드 호출로 결과가 리턴될 때마다, 
        
        옵저버의 메서드는 리턴 값 또는 (Observable이 배출하는)*항목들*을 사용해서 연산을 시작
        
- **Subscriber** : 옵저버 인터페이스
    - Observable의 이벤트를 구독하고 처리하는 객체
    - Subscriber는 onNext, onError, onComplete 등의 이벤트에 대한 처리를 정의할 수 있다.
- 옵저버와 옵저버블을 연결하는 Subscribe 메서드 세가지 onNext, onCompleted, onError
    - onNext
        - 옵저버블(Observable)이 이벤트(데이터)를 **발생**할 때 호출되는 메서드
        - 발생한 데이터를 파라미터로 옵저버에게 **전달, `subscribe(onNext:)`**
        - 옵저버가 옵저버블의 데이터를 처리
    - onCompleted
        - 옵저버블이 모든 이벤트를 성공적으로 **완료**했을 때 호출되는 메서드
        - 이벤트의 처리가 끝났음을 옵저버에게 **알리는** 역할, **`subscribe(onCompleted:)`**
        - 옵저버에게 특정 작업을 수행하게 지시
    - onError
        - 옵저버블이 **오류가 발생**했을 때 호출되는 메서드
        - 오류 상황을 옵저버에게 **알리는** 역할, **`subscribe(onError:)`**
        - 옵저버에게 특정 작업을 수행하게 지시
    - 특징
        - 세가지 모두 **`subscribe()`** 메서드와 함께 사용
        - onNext는 0번이상 호출, 마지막 onNext 호출 후 onCompleted / onError 둘 중 하나만 호출
        - onNext호출 == 배출(emissions) - 문서공식용어
        - onCompleted / onError호출 == 알림(notifications) - 문서공식용어
        - onError가 호출되면 onNext, onCompleted는 더이상 호출되지 않음
- 구독 해지
    - unsubscribe()메서드 : 구독 해지할 때
        - 해지 원리 : 연산자 체인을 통해 옵저버가 구독하고 있었던 옵저버블들이 더 이상 항목들을 배출하지 못하도록 체인 내 연결들을 끊음
- 명명 규칙에 관한 참고 내용
    - (`onNext`, `onCompleted`, `onError` 같은) `on*Event*` 네이밍 패턴 존재
    - 문맥에 따라 위 네이밍은 어떤 핸들러가 등록되었는지를 가리키는 메서드❌ 로 사용되기도 함
    - 그러나 ReactiveX에서는 ⭕️ 이벤트핸들러 자체를 의미함
---

## 🟡 **“뜨거운(Hot)” , “차가운(Cold)” Observable**
연속된 항목들을 언제 배출(onNext호출)?
옵저버블에 따라 다름
- Hot 옵저버블 생성되자마자 항목들 배출, 계속 배출하는 중간에 옵저버들이 옵저버블 구독 가능
- Cold 옵저버블 옵저버가 구독할 때까지 항목 배출 안함, 대신 구독하면 배출항목 전체 보장받음
- Connectable 옵저버블
    옵저버의 구독여부와 무관, 자신의 Connect메서드가 호출되기 전까지는 항목 배출 안함
    
---

## 🟡 ****Observable 연산자를 활용한 구성****
- 옵저버블, 옵저버 - ReactiveX(reactive extensions)의 시작점, 기존 옵저버패턴 확장한 정도
- 연속된 이벤트 처리 시 싱글 콜백보다는 더 효과적
    - 싱글콜백 : 비동기 작업이 완료되었을 때 한 번만 호출되는 콜백 함수
    - 콜백함수 : completion handler를 갖고있는 함수
    - 콜백 : 특정 작업 다음 동작이 정해져 있고, 비동기적인 작업 완료 시 정해놓은 동작을 실행하는 것
- **연산자** - ReactiveX의 핵심
    - 옵저버블이 배출하는 연속된 항목들을 변환, 결합, 조작하는 기능 제공
    
    > 콜백이 제공하는 효율적인 장점들을 바탕으로 **선언적인 방법**을 통해 연속된 비동기 호출을 구성할 수 있는 방법을 제공하는데, 중요한 것은 일반적인 비동기 시스템이 가진 중첩된 콜백 핸들러의 단점들을 제거했다는 점이다.
    > 
    - 선언적인 방법
        - 프로그래밍에서 원하는 결과를 달성하기 위해 "무엇"을 얻고 싶은지를 명시적으로 표현하는 방식
        - ❌"어떻게" : 어떤 동작을 수행하는 방법을 직접 명령하거나 조작
        - ⭕️“무엇을” : 원하는 결과를 표현, 시스템이 그 결과를 얻는 방법을 추론하도록 하는 것
    - ✚ 예시
        - 선언적인 연산자 filter(걸러내겠다), map(하나씩매핑하겠다) 사용
    
    ```swift
    Observable.from([1, 2, 3, 4, 5])    //데이터 스트림 생성
        .filter { $0 % 2 == 0 }         //짝수를 필터링
        .map { $0 * 2 }                 //각 요소를 2배로 변형
        .subscribe(onNext: { print($0) })  //출력
    ```
    
- 연산자 별 상세설명 - [https://reactivex.io/documentation/ko/operators.html](https://reactivex.io/documentation/ko/operators.html)
- 연산자 체인
    - 연산자들은 Observable 상에서 동작하고 Observable을 리턴한다.
    - 하나의 옵저버블에 여러개의 연산자를 하나씩 차례로 적용할 수 있는 **연산자 체인**을 제공한다.
    - 연산자 체인에 걸린 각 연산자들은 이전 연산자가 리턴한 옵저버블을 변경한다.
    - 원본 옵저버블과는 떨어져서 동작불가, 호출 순서대로 동작
    
- 빌더 패턴
  
    특정 클래스의 다양한 메서드 연산을 통해서 같은 클래스에 있는 항목들을 변경하는 것
  
    이 패턴에서도 비슷한 방식으로 **메서드 체인**을 제공한다.
    
- 차이점
  
    빌더패턴은 메서드의 호출순서와 무관
  
    옵저버블 연산자들은 호출순서에 영향을 받는다.
---
